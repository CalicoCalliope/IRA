import os
import sys
from pathlib import Path
from typing import List, Optional
from fastapi import Query
from .milvusService import insert_embedding, filter_entries

# Ensure repo root is importable so we can import `ira.*`
REPO_ROOT = Path(__file__).resolve().parents[2]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

from fastapi import FastAPI
from pydantic import BaseModel, Field

# Import your existing pipeline (has its own google-research path shim)
from . import cubert_pipeline as pipe  # type: ignore

app = FastAPI(title="Embedder Service", version="0.1.0")

class EmbedRequest(BaseModel):
    text: str = Field(..., description="Source text to embed")
    primary_key: str # ID generated by coordinator
    username: str
    pem_type: str
    timestamp: float # timestamp generated by coordinator (seconds since epoch)

class EmbedResponse(BaseModel):
    vector: List[float]
    dim: int
    primary_key: str
    timestamp: float

class FilterRequest(BaseModel):
    username: str | None = None
    pem_type: str | None = None
    n_results: int = 100

class FilterResponseItem(BaseModel):
    primary_key: str
    embedding: List[float]
    timestamp: int
    username: str
    pem_type: str

class FilterResponse(BaseModel):
    embeddings: List[FilterResponseItem]

class HealthResponse(BaseModel):
    cubert_src: str
    cubert_src_exists: bool
    spm_path: str
    spm_exists: bool
    use_hf_only: bool
    model_name: str

@app.get("/health", response_model=HealthResponse)
def health() -> HealthResponse:
    # Build a simple health payload without loading heavy models
    cubert_src = str(pipe.CUBERT_SRC)
    spm_path = str(pipe.SPM_PATH)
    return HealthResponse(
        cubert_src=cubert_src,
        cubert_src_exists=pipe.CUBERT_SRC.exists(),
        spm_path=spm_path,
        spm_exists=pipe.SPM_PATH.exists(),
        use_hf_only=bool(pipe.USE_HF_ONLY),
        model_name=str(pipe.MODEL_NAME),
    )

@app.post("/embed", response_model=EmbedResponse)
def embed(req: EmbedRequest) -> EmbedResponse:
    vec = pipe.get_cubert_embedding(req.text)

    dim = len(vec)
    # Default to 768 to match production Milvus; override with env for dev (0) or other dims.
    EXPECT_DIM = int(os.getenv("MILVUS_EXPECT_DIM", "768") or "768")
    if EXPECT_DIM and dim != EXPECT_DIM:
        raise ValueError(f"Embedding dimension {dim} != expected {EXPECT_DIM}")

    # vec is a numpy array per the pipeline; convert to list for JSON
    lst = [float(x) for x in vec.tolist()]

    # insert into Milvus
    insert_embedding(lst, req.primary_key, req.username, req.pem_type, int(req.timestamp))

    return EmbedResponse(vector=lst, dim=len(lst), primary_key=req.primary_key, timestamp=req.timestamp)

@app.get("/filter", response_model=FilterResponse)
def filter_embeddings(
    username: Optional[str] = Query(None),
    pem_type: Optional[str] = Query(None),
    n_results: int = Query(100)
):
    raw_results = filter_entries(username=username, pem_type=pem_type, n_results=n_results)
    print("FILTER RESULTS:", raw_results)

    results = []
    for r in raw_results:
        # Map Milvus field names to Pydantic fields
        pk = r.get("primary_key") or r.get("id")  # fallback if Milvus returns 'id'
        if pk is None:
            continue  # skip rows with missing PK
        results.append(FilterResponseItem(
            primary_key=str(pk),  # ensure string
            embedding=r["embedding"],
            timestamp=r["timestamp"],
            username=r["username"],
            pem_type=r["pem_type"]
        ))

    return FilterResponse(embeddings=results)

# Dev entrypoint: uvicorn app:app
if __name__ == "__main__":
    import uvicorn
    # Ensure google-research is on PYTHONPATH for safety if run directly
    gr = REPO_ROOT / "google-research"
    env = os.environ.copy()
    env["PYTHONPATH"] = f"{env.get('PYTHONPATH','')}:{gr}"
    uvicorn.run("app:app", host="127.0.0.1", port=8001, reload=False)
