import os
import sys
from pathlib import Path
from typing import List, Optional
from fastapi import Query
try:
    from .milvusService import insert_embedding, filter_entries
except Exception:
    from .milvus_noop import insert_embedding, filter_entries

# Ensure repo root is importable so we can import `ira.*`
REPO_ROOT = Path(__file__).resolve().parents[2]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

from fastapi import FastAPI
from pydantic import BaseModel, Field

# Import your existing pipeline (has its own google-research path shim)
from . import cubert_pipeline as pipe  # type: ignore

app = FastAPI(title="Embedder Service", version="0.1.0")

class EmbedRequest(BaseModel):
    text: str = Field(..., description="Source text to embed")
    id: str # ID generated by coordinator
    username: str
    pemType: str
    timestamp: float # timestamp generated by coordinator (seconds since epoch)

class EmbedResponse(BaseModel):
    vector: List[float]
    dim: int
    id: str
    timestamp: float

class FilterRequest(BaseModel):
    username: str | None = None
    pemType: str | None = None
    n_results: int = 100

class FilterResponseItem(BaseModel):
    id: str
    embedding: List[float]
    timestamp: int
    username: str
    pem_type: str

class FilterResponse(BaseModel):
    embeddings: List[FilterResponseItem]

class HealthResponse(BaseModel):
    cubert_src: str
    cubert_src_exists: bool
    spm_path: str
    spm_exists: bool
    use_hf_only: bool
    model_name: str

@app.get("/health", response_model=HealthResponse)
def health() -> HealthResponse:
    # Build a simple health payload without loading heavy models
    cubert_src = str(pipe.CUBERT_SRC)
    spm_path = str(pipe.SPM_PATH)
    return HealthResponse(
        cubert_src=cubert_src,
        cubert_src_exists=pipe.CUBERT_SRC.exists(),
        spm_path=spm_path,
        spm_exists=pipe.SPM_PATH.exists(),
        use_hf_only=bool(pipe.USE_HF_ONLY),
        model_name=str(pipe.MODEL_NAME),
    )

@app.post("/embed", response_model=EmbedResponse)
def embed(req: EmbedRequest) -> EmbedResponse:
    vec = pipe.get_cubert_embedding(req.text)

    dim = len(vec)
    EXPECT_DIM = int(os.getenv("MILVUS_EXPECT_DIM", "0") or "0")
    if EXPECT_DIM and dim != EXPECT_DIM:
        raise ValueError(f"Embedding dimension {dim} != expected {EXPECT_DIM}")

    # vec is a numpy array per the pipeline; convert to list for JSON
    lst = [float(x) for x in vec.tolist()]

    # insert into Milvus
    insert_embedding(lst, req.id, req.username, req.pemType, int(req.timestamp))

    return EmbedResponse(vector=lst, dim=len(lst), id=req.id, timestamp=req.timestamp)

@app.get("/filter", response_model=FilterResponse)
def filter_embeddings(
    username: Optional[str] = Query(None, description="Filter by username"),
    pemType: Optional[str] = Query(None, description="Filter by PEM type"),
    n_results: int = Query(100, description="Max number of results")
):
    """
    Retrieve embeddings filtered by username and/or PEM type.
    Returns the embedding ID, vector, timestamp, username, and PEM type.
    """
    results = filter_entries(username=username, pem_type=pemType, n_results=n_results)
    return FilterResponse(embeddings=results)

# Dev entrypoint: uvicorn app:app
if __name__ == "__main__":
    import uvicorn
    # Ensure google-research is on PYTHONPATH for safety if run directly
    gr = REPO_ROOT / "google-research"
    env = os.environ.copy()
    env["PYTHONPATH"] = f"{env.get('PYTHONPATH','')}:{gr}"
    uvicorn.run("app:app", host="127.0.0.1", port=8001, reload=False)
